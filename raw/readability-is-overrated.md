Readability is important, but it's not something that we should hold as the holy grail of programming. It's a  defined aspiration that is broad, vague and subjectively. Maybe factors contribute to readability as well as sabotage it. Over time it has become one of these words like "agile", "clean" or "simple"; I used to know what they mean (or so I believed), but not any more. It's often more helpful to use more specific, accurate terms.

## Not-so-useful goals

### code should be readable for anybody


### code should be readable for a junior engineer

## Not-so-useful conventions

### magic frameworks

### long jumps

### 



Basically, any measure that makes reasoning with code more difficult. There are some rough measures,

* linear is easier than non-linear
* straight-forward is easier than intertwined
* the less branching, the easier
* self-contained is easier than dependent
* explicit is easier than implicit
* succinct is easier than verbose
* constant is better than ever-changing
* predictable is better than surprises

You would have noticed, some measures may conflict with others, when not applied well. How to find a good balance is where the good minds of a mature engineer comes in.

### 



Language and Vocabulary

Author and Audience

## Useful Measurement

### Aesthetics, Layout and Formatting

### Verbose vs Succinct, Declarative vs Imperative

> The two functors F and G are called naturally isomorphic if there exists a natural transformation from F to G such that Î·X is an isomorphism for every object X in C.

Is this readable? Very much. I can read every word (yes, even **functor** :smug face:), and I can read the whole sentence; I understand the logic up to the point that the existence of a "natural transformation" is prerequisite to "natural isomorphism", but alas, I don't understand what this short sentence really means.

And that's a big problem with how people talk about readability today.

IT's not a disguise for closed-mindedness 

Objectively readability

But this has diminishing returns. Sorting imports alphabetically do not necessarily improve readability.

For good economy I would not spend too much time on absolute consistency. Sometimes, it may be OK or even beneficial to have slightly varying code, design or philosophy in a team. 

Everything else is ... subjective.

Chinese - to read newspapers, one need between 2000 to 3000 characters.

I can't read category theory, but it doesn't mean it's not readable.

Key factor to readability, 

## How comfortable are you with a certain way of writing code?

## How familiar are you with the languages, libraries or tools?

## Specialisation

## Vocabulary 

In general, these items should be included in the vocabulary of a modern engineers.

- the basics of any turing-complete, general purpose language
- generics
- list comprehension, or by different names: array functions
- lambdas, or passing function as parameters (first-class, values)
- immutability, expressions, value classes / data classes
- pattern matching
- union types - depending on the choice of language